<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
<meta charset="utf-8">
<meta name="author" content="Rodrigo Strauss">
<meta name="ROBOTS" content="ALL">
    <title>Blog  ::::  Rodrigo Strauss :: www.1bit.com.br</title>
    <link href="../../1bit.css" type="text/css" rel="stylesheet">
    <link rel="alternate" type="application/rss+xml" title="RSS" href="../../weblog_rss.1bit">
</head>
  <body style="margin:0px 0px 0px 0px" bgcolor="#FFFFFF">
    <table cellspacing="0" cellpadding="0" width="100%" border="0">
        <tr>
          <td class="header" valign="middle" bgcolor="#ffffff" height="77" colspan="2">&nbsp;
<a href="../../"><img src="../../images/logo_novo_2.png" border="0" alt="logo"/></a>

          </td>
        </tr>
        <tr>
          <td class="topmenu"></td>
          <td class="topmenu" align="right" height="30">
		    <a class="top_menu_link" href="../../content.1bit/links">Links</a> 
			<span class="menusep">|</span>

		    <a class="top_menu_link" href="../../content.1bit/contact">Contato</a> 
			<span class="menusep">|</span>
            
		    <a class="top_menu_link" href="../../content.1bit/busca">Busca no site</a> 
			<span class="menusep">|</span>

            <a class="top_menu_link" href="../../content.1bit/about">Sobre...</a>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          </td>
        </tr>
        <tr>
          <td class="topmenu"></td>
          <td>
          <table style="MARGIN: 0px" cellspacing="0" cellpadding="0" width="100%" border="0">
            <tr>
              <td><img src="../../images/rebarba1.png" alt="rebarba"></td>
              <td align="right"><img src="../../images/rebarba2.png" alt="rebarba"></td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td class="menu" valign="top" width="175">

<div class="left_menu_section">
 <h2><a href="../../#artigos" style="text-decoration:none;">Artigos</a></h2>
</div>

<div class="left_menu_section">
 <h2><a href="../../content.1bit/weblog" style="text-decoration:none;">Blog</a></h2>
</div>

<div class="left_menu_section">
 <h2><a href="../../cpp/wiki" style="text-decoration:none;">Wiki C/C++</a></h2>
</div>

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
<br><br><br><br>
          </td>
          <td valign="top">
<div class="content">
<h4><a href="../../content.1bit/weblog" style="text-decoration:none;">Rodrigo Strauss :: Blog</a></h4>
<a style="text-decoration:none;" href="../../weblog_rss.1bit"><img src="../../images/xml.gif" border="0"/></a>
<br>

<p style="font-size:9pt;"><i>Talvez você ache interessante ver a <a href="../../content.1bit/weblog_categ">lista dos melhores posts organizados por categoria</a>, ou uma <a href="../../content.1bit/weblog_archive">lista com todos eles</a>.</i></p>


<h5><a class="weblog_link" href="../../content.1bit/weblog/meu_caso_com_o_python_2">Meu caso com o Python, parte 2</a></h5><p><i>continuação da <a href="../../content.1bit/weblog/meu_caso_com_o_python_1">parte 1</a></i></a>
<p>Com essa minha experiência com Python cheguei à uma conclusão interessante. Sou um apaixonado por programação e suas linguagens, não necessariamente apaixonado por C++. A parte do meu cérebro que responde pelo C++ se sente um pouco traída, já que a exclusividade acaba. Mas a parte que cuida do bom senso fica cada dia mais feliz. Não sendo eu somente um fanático programador C++, passo cada dia mais a confiar na minha (possível) imparcialidade e bom senso quando o assunto é programação. E minha parte C++ fica mais feliz ainda por isso ser uma evidência de que escolhi o C++ não porque é algo complicado somente para nerds e escovadores de bit, e sim porque tem suas inúmeras qualidades e é, indiscutívelmente, a melhor ferramenta disponível para determinados tipos de projetos. Eu sempre escrevi sobre usar a melhor ferramenta disponível para sua tarefa. Mas talvez minha relutância em usar algo que não C++ falava contra mim, apesar de fazer todo o sentido. Tudo resolvido agora. :-)</p>

<p>Ouvi uma história uma vez que resume tudo:</p>

<p><i>Imagine um carro de Formula 1. O volante é muito sensível. Quando você pisa no acelerador, ele arranca e você cola no banco. Se você não freia com cuidado, é quase arremessado para fora do carro. Ele é desconfortável, apertado, faz bastante barulho. Só que ele é o mais rápido que existe. Coisa para profissionais. Assim é o C++.</i></p>

<p>Coisa para profissionais. Quando você treina bastante, é o melhor carro do mundo. Mas usar um Formula 1 para fazer compras, no trânsito de São Paulo, não é viável. É muito legal, é muito divertido, mas pouco viável.</p>

<p>Lembre-se: não é lei do mínimo esforço. É a lei de o esforço necessário, de não desperdiçar o esforço. É sobre isso a frase "usar a ferramenta certa para o problema certo". Note que não estou dizendo que só percebi isso graças ao Python, mas digamos que o Python me parece o melhor carro de passeio que existe para fazer compras no supermercado... :-)</a>

<p>Algumas coisas que eu gostei muito no Python em relação ao C++ e aos wannabes (C#/Java):
<ul>
<li>O ciclo <i>while(1){arruma-compila-debuga}</i> quase desaparece. Você vai escrevendo código no console e testando, em runtime ou não. Funcionou? Copia do console e cola no fontes, um trecho de código já testado.<li>
<li>A linguagem é muito legível e simples. Em alguns casos, é uma especificação que roda e funciona. Por isso que existe bastante gente escrevendo protótipos em Python e depois refazendo tudo em C++, depois que o conceito está testado. Eu sou um deles :-)</li>
<li><i>Batteries Included</i>. Quase tudo que você precisa vem na distribuição padrão (como o .NET Framework e as bibliotecas Java, só que com um pouco a mais). Precisa fazer profiling? A distribuição padrão tem 3. Unit Test? Sim, na distribuição padrão. Web Server em Python? Sim também. Regex? Threads? SMTP? XML-RPC? Sockets? Criptografia? XML? Biblioteca de Log? HTTP com tratamento de Cookies? <a href="http://docs.python.org/lib/lib.html">Sim.</a>
</ul>

<p>E, claro, encontrei também defeitos:</p>
<ul>
<li>Um código feito em Python é bem legível, o que faz com que muito programadores Python relevem a importância dos comentários no código. <a href="../../content.1bit/weblog/code_comments">Minha opinião sobre isso não muda</a>, independente da linguagem.</li>
<li>Não existe livro avançado de Python. Estou acostumado com C++, onde existe muitos livros avançados. Os de Python ou são tutoriais ou cookbooks.</li>
<li>Sim, é lento em runtime (geralmente mais do que C# ou Java, <a href="http://psyco.sourceforge.net/">mas nem sempre</a>). Mas extremamente produtivo (muito mais do que C# ou Java). Ou seja, é bem usado quando não se precisa de performance ou quando o tempo de I/O ou rede é tão grande em relação ao resto do processo que o tempo da linguagem se torna quase desprezível. </li>
</ul>

<p>Minha opinião pode não valer muito em termos de convencer as pessoas sobre o que o Python pode oferecer. Mas acredito que a opinião do Google, Nasa, ILM, YouTube e <a href="http://python.org/about/success">outros</a> deve valer um pouco mais. :-)</p>

<p>Pronto, confessei, eu tenho outra (linguagem). Nem foi tão difícil quanto eu pensava...</p><p class="datetime">Em 07/03/2007 11:48&nbsp;-&nbsp;<a href="../../content.1bit/weblog/meu_caso_com_o_python_2#comments">Comentários (11)</a></p><h5><a class="weblog_link" href="../../content.1bit/weblog/1172289620">Link para o download do Visual C++ Toolkit  2003</a></h5><p>A Microsoft (tá bom, a área de vendas da Microsoft) tem a PÉSSIMA E ESTÚPIDA mania de achar que quando é lançada uma versão de um software, as versões antigas não são mais necessárias, são péssimas e cheias de defeitos. O próprio Bill Gates falou mal do Office 2000 para tentar vender o 2003, por exemplo.

<p>Tratando-se de compiladores C++, é necessário alguns cuidados para carregar em um EXE uma DLL compilada com uma versão diferente. Muitos projetos open source exigem uma versão específica do compilador. <a href="http://msdn.microsoft.com/visualc/vctoolkit2003/">Por mais que o Visual C++ Express 2005 seja melhor do que o Visual C++ Toolkit 2003</a>, algumas pessoas precisam dessa versão específica. Que, é claro, é impossível de achar no site da Microsoft.

<p>Ainda bem que alguma boa alma disponibiliza isso. <a href="http://xona.com/programs/VCToolkitSetup(v1.01)(2004.07.06).zip">Download do Visual C++ Toolkit 2003</a>, eu testei, funciona.</p><p class="datetime">Em 23/02/2007 19:00&nbsp;-&nbsp;<a href="../../content.1bit/weblog/1172289620#comments">Comentários (5)</a></p><h5><a class="weblog_link" href="../../content.1bit/weblog/artigos_sobre_unmanaged_vista">Artigos sobre Unmanaged Vista</a></h5><p>Bons artigos sobre o Windows Vista, em raros casos onde o termo .NET não aparece:</p>

<ul>
<li><a href="http://www.codeproject.com/useritems/umvistad3d.asp">Unmanaged Vista Power</a> - Como usar as APIs de composição do Windows Vista em C++, sem usar WPF.</li>
<li><a href="http://www.microsoft.com/technet/technetmag/issues/2007/02/VistaKernel/">Inside Windows Vista Kernel, Part 1</a> - Artigo sobre a melhorias do kernel do Windows Vista. Pelo mestre dos mestre, Mark Russinovich.</a>
<li><a href="http://www.microsoft.com/technet/technetmag/issues/2007/03/VistaKernel/">Inside Windows Vista Kernel, Part 2</a> - continuação da série.</li>
<li><a href="http://www.codeproject.com/vista/#Vista+Native+APIs">Vista Native APIs</a> - Categoria do Code Project sobre as novas APIs unmanaged do Vista.</li>
</ul><p class="datetime">Em 23/02/2007 08:47&nbsp;-&nbsp;<a href="../../content.1bit/weblog/artigos_sobre_unmanaged_vista#comments">Comentários (0)</a></p><h5><a class="weblog_link" href="../../content.1bit/weblog/meu_caso_com_o_python_1">Meu caso com o Python, parte 1</a></h5><p>Acredito que vocês têm percebido que, além de tudo que eu falo, faço e escrevo usando C++, eu tenho falado bastante sobre Python. Além de falar eu tenho estudado muito Python de um ano pra cá, e em alguns projetos tenho usado mais Python do que C++. Como isso foi uma mudança grande para mim, acho que essa experiência pode ser aproveitada por mais pessoas.</p>

<p>Acredito que a maioria dos programadores usam scripts para automatizar tarefas repetitivas. Para algumas tarefas, talvez teria sido melhor fazer um programa completo e compilado, mas foi mais simples migrar um .BAT para um .VBS (ou usar shell script de uma vez...) e ficar remendando ele resolver o problema. Até que você encontra um grande problema: quando seu script começa a ficar maior e mais complexo, você acaba batendo toda hora nos limites das linguagens (foi isso que me fez pular do VB6 para o C++). Tendo esse problema algumas vezes, e lendo sobre todo o hype em cima das ditas linguagens dinâmicas, resolvi estudar se haviam realmente linguagens de script com mais poder de fogo.</p>

<p>Depois de uma pequena procura cheguei a conclusão que haviam dois candidatos: Python e Ruby. Estudando a linguagem pura e simplesmente, achei o Ruby melhor. Comecei a estudar Ruby enquanto lia mais sobre Python. Mas uma coisa muito importante me fez decidir pelo Python: suporte, literatura e bibliotecas. Apesar do Ruby estar crescendo devido ao <a href="http://www.rubyonrails.org/">Ruby On Rails</a> (e ao ótimo marketing do seu criador), o Python já era usado pelo Google, NASA, e por muita gente no Source Forge. Então, por razões mais mercadológicas que puristas, escolhi o Python.</p>

<p>A melhor forma de se estudar uma linguagem é determinar um projeto e trabalhar nele. Essa história de ficar lendo tutorial e fazendo exercícios simples não é lá de muita valia. Foi então que eu decidi migram um script VBScript que eu usava para compilar meus projetos Visual C++ para Python. Esse script encontrava o número de revisão do Subversion, mudava o arquivo de resource para colocar a revisão no FILEVERSION e compilava o projeto. Resultado: 120 linhas de código VBS se transformaram em 20 linhas de código Python. E o código ficou mais claro e mais eficiente. Percebi que fiz uma boa escolha, e isso me animou a migrar outros scripts para Python e a passar o dia com o console Python aberto para automatizar tarefas simples.</p>

<p><i>continua...</i></p><p class="datetime">Em 20/02/2007 06:30&nbsp;-&nbsp;<a href="../../content.1bit/weblog/meu_caso_com_o_python_1#comments">Comentários (7)</a></p><h5><a class="weblog_link" href="../../content.1bit/weblog/stl_tutorial_5">Tutorial de STL, parte 5: algoritmos</a></h5><p>Hoje vamos falar sobre os algoritmos da STL (algorithms), que nada mais são que as funções template que efetuam algum tipo de operação sobre os itens de um container. Isso mesmo, os tais <i>algorithms</i> nada mais são do que funções. O que os faz especiais é a programação genérica, que permite que um mesmo algoritmo possa ser aplicado a diversos tipos de containers, sem distinção. Dessa forma, ao invés de cada container prover métodos com o algoritmos necessários, todos eles ficam separados e pode ser aplicados a maioria deles.</p>

<p>Para tornar os algoritmos genéricos, precisamos primeiro abstrair os containers. Existem duas formas básicas para resolver isso em C++: usando interfaces e funções virtuais, ou fazendo o chamado "polimorfismo em tempo de compilação", usando templates e concepts, onde ter os métodos 
100 23848    0 23848    0     0   8158      0 --:--:--  0:00:02 --:--:-- 40307
das classes com os mesmos nomes já é suficiente. A primeira opção não se enquadra no conceito C++ de "generic programming", e apesar da segunda se enquadrar, não é possível usá-la com os containers STL. Por exemplo, apesar da maioria dos containers oferecer o método push_back, alguns não o fazem (como o std::map).</p>

<p>Como dito na <a href="../../content.1bit/weblog/stl_tutorial_4">parte 4 dessa série sobre STL</a>, o conceito de iterators existe para abstrair as particularidades do armazenamento de cada container. Dessa forma, a ação de acessar e percorrer os itens de um container se torna igual para a maioria dos containers. Apesar de não ser possível abstrair todas as características de um container, a abstração da forma de acesso aos itens já é suficiente para que os algortimos funcionem. Além disso, isso torna tudo mais flexível, já que permite que você aplique um algoritmos somente em determinados itens de um container.</p>

<p>Como um trecho de código vale muito mais do que uma <a href="../../content.1bit/weblog/lei_estupida">lei estúpida feita por alguém mal informado</a>, vamos lá:</p>

<div class="code"><pre><span class="keyword">#include</span> &lt;vector&gt;<span class="keyword">
#include</span> &lt;algorithm&gt;<span class="keyword">
#include</span> &lt;assert.h&gt;
&nbsp;
<span class="comment">//
</span><span class="comment">// esse é o nosso algoritmo que soma um número a
</span><span class="comment">// cada item de um container. Note que durante a execução
</span><span class="comment">// o tipo T será o tipo do iterator, e não do container
</span><span class="comment">//
</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T &gt;
<span class="keyword">void</span> soma_num(T begin, T end, <span class="keyword">int</span> num)
{
  <span class="keyword">for</span>(T i = begin; i != end ; ++i)
    *i += num;
}
&nbsp;
&nbsp;
<span class="keyword">int</span> main()
{
  std::vector&lt;<span class="keyword">int</span>&gt; v;
  std::vector&lt;<span class="keyword">int</span>&gt; l;
  <span class="keyword">int</span> arr[10];

  <span class="keyword">for</span>(<span class="keyword">int</span> a = 0 ; a &lt; 10 ; ++a)
  {
    v.push_back(a);
    l.push_back(a);
    arr[a] = a;
  }
&nbsp;
  <span class="comment">//
</span>  <span class="comment">// vamos somar 10 aos número de todos os containers
</span>  <span class="comment">//
</span>  soma_num(v.begin(), v.end(), 10);
  soma_num(l.begin(), l.end(), 10);
&nbsp;
  <span class="comment">//
</span>  <span class="comment">// somando 10 somente aos 5 primeiros itens do array
</span>  <span class="comment">//
</span>  soma_num(arr, arr + 5, 10);
}</pre></div>

<p>Para maioria dos algoritmos, o acesso a todos os itens do container já á mais do que suficiente. A STL contém diversos algoritmos em várias áreas, entre eles:</p>

<ul>
<li>procurar itens dentro de um container (find, find_if)</li>
<li>contar itens que atendem a uma determinada condição (count, count_if)</li>
<li>cópia de itens entre containers e trechos de containers (copy, copy_n)</li>
<li>o famoso <a href="http://labs.google.com/papers/mapreduce.html">map reduce</a> (transform, accumulate)</li>
<li>troca de itens (reverse, swap, rotate)</li>
<li>operações com std::set, conjuntos (set_union, set_intersection, set_difference)</li>
<li>e muitos outros (min, max, random_shuffle, fill generate)</li>
</ul>

<p>A lista e documentação dos algoritmos pode ser encontrada na página da <a href="http://www.sgi.com/tech/stl/table_of_contents.html">SGI</a> ou na <a href="http://msdn2.microsoft.com/en-us/library/wh15hsex(VS.80).aspx">MSDN</a>. Segue um exemplo de uso dos algoritmos:


<div class="code">
<pre><span class="keyword">int</span> main()
{
  std::vector&lt;<span class="keyword">int</span>&gt; v1, v2;
&nbsp;
  <span class="keyword">for</span>(<span class="keyword">int</span> a = 0 ; a &lt; 100 ; ++a)
    v1.push_back(a);
&nbsp;
  <span class="comment">//
</span>  <span class="comment">// cria um iterator especial que insere um novo
</span>  <span class="comment">// items em um container toda vez que houver 
</span>  <span class="comment">// uma atribuição. 
</span>  <span class="comment">//
</span>  std::back_insert_iterator&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt; bi(v2);
&nbsp;
  <span class="comment">//
</span>  <span class="comment">// isso faria um v2.push_back(10);
</span>  <span class="comment">// *bi = 10;  
</span>  <span class="comment">//
</span>&nbsp;
  <span class="comment">//
</span>  <span class="comment">// vamos copiar os itens de um container para outro.
</span>  <span class="comment">// o algoritmo copy tem duas linhas: é um loop for
</span>  <span class="comment">// que copia todos os itens em sequência. Veja os fontes
</span>  <span class="comment">// em <a href="http://www.koders.com/cpp/fidA53A04CB0D586F1D66573787E06C370EA1DCEA40.aspx?s=stl_algo+find#L97">stl_algo.h</a>
</span>  <span class="comment">//
</span>  std::copy(v1.begin(), v1.end(), bi);
&nbsp;
  <span class="comment">//
</span>  <span class="comment">// embaralha o v1
</span>  <span class="comment">//
</span>  std::random_shuffle(v1.begin(), v1.end());
&nbsp;
  <span class="comment">//
</span>  <span class="comment">// ordena v1
</span>  <span class="comment">//
</span>  std::sort(v1.begin(), v1.end());
&nbsp;
  <span class="keyword">for</span>(<span class="keyword">int</span> x = 0 ; x &lt; 100 ; ++x)
  {
    assert(v1[x] == v2[x]);
  }
}</pre>
</div><p class="datetime">Em 13/02/2007 10:26&nbsp;-&nbsp;<a href="../../content.1bit/weblog/stl_tutorial_5#comments">Comentários (0)</a></p><br><a href="../../content.1bit/weblog?before=1171394803">Posts anteriores &gt;&gt;</a><br>
</div>
          </td>
        </tr>

<tr>
          <td class="topmenu"></td>
          <td>
          <table style="margin: 0px" cellspacing="0" cellpadding="0" width="100%" border="0">
            <tr>
              <td><img src="../../images/rebarba3.png" alt="rebarba"></td>
              <td align="right"><img src="../../images/rebarba4.png" alt="rebarba"></td>
            </tr>
          </table>
          </td>
        </tr>

        <tr>
          <td class="topmenu">&nbsp;</td>
          <td class="topmenu" height="25" align="right" style="color:#999999;">
::::
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          </td>
        </tr>
    </table>
  </body>
</html>

