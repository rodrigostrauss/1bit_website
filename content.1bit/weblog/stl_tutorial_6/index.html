

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
<meta charset="utf-8">

<META NAME="author" CONTENT="Rodrigo Strauss">
<META NAME="ROBOTS" CONTENT="ALL">
    <title>Tutorial de STL, parte 6: Functors  ::::  Rodrigo Strauss :: www.1bit.com.br</title>
    <link href="../../../1bit.css" type="text/css" rel="stylesheet">
    <link rel="alternate" type="text/xml" title="RSS" href="../../../weblog_rss.1bit">
</head>
  <body style="margin:0px 0px 0px 0px" bgcolor="#FFFFFF">
    <table cellspacing="0" cellpadding="0" width="100%" border="0">
        <tr>
          <td class="header" valign="middle" bgcolor="#ffffff" height="77" colspan="2">&nbsp;
<a href="../../../"><img src="../../../images/logo_novo_2.png" border="0" alt="logo" /></a>

          </td>
        </tr>
        <tr>
          <td class="topmenu"></td>
          <td class="topmenu" align="right" height="30">
		    <a class="top_menu_link" href="content.1bit/contact">Contato</a> 
			<span class="menusep">|</span>
            
            <a class="top_menu_link" href="content.1bit/about">Sobre...</a>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          </td>
        </tr>
        <tr>
          <td class="topmenu"></td>
          <td>
          <table style="MARGIN: 0px" cellspacing="0" cellpadding="0" width="100%" border="0">
            <tr>
              <td><img src="../../../images/rebarba1.png" alt="rebarba"></td>
              <td align="right"><img src="../../../images/rebarba2.png" alt="rebarba"></td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td class="menu" valign="top" width="175">

<div class="left_menu_section">
 <h2><a href="../../#artigos" style="text-decoration:none;">Artigos</a></h2>
</div>

<div class="left_menu_section">
 <h2><a href="content.1bit/weblog" style="text-decoration:none;">Blog</a></h2>
</div>

<div class="left_menu_section">
 <h2><a href="content.1bit/opensource" style="text-decoration:none;">Open Source</a></h2>
</div>

<!-- 
<div class="left_menu_section">
 <h2><a href="content.1bit/aulas" style="text-decoration:none;">Aulas online (ou nÃ£o) </a></h2>
</div>
-->

<br>

<!-- SiteSearch Google -->
<form method="get" action="http://www.google.com.br/custom" target="_top">
<table border="0" bgcolor="#eeeeee">
<tr><td nowrap="nowrap" valign="top" align="left" height="32">
<a href="http://www.google.com/">
<img src="http://www.google.com/logos/Logo_25wht.gif" border="0" alt="Google" align="middle"></img></a>
<br/>
<input type="hidden" name="domains" value="www.1bit.com.br"></input>
<label for="sbi" style="display: none">Digite os termos da sua pesquisa</label>
<input type="text" name="q" size="23" maxlength="255" value="" id="sbi"></input>
</td></tr>
<tr>
<td nowrap="nowrap">
<table>
<tr>
<td>
<input type="radio" name="sitesearch" value="" id="ss0"></input>
<label for="ss0" title="Pesquisar na web"><font size="-2" color="black">Web</font></label></td>
<td>
<input type="radio" name="sitesearch" value="www.1bit.com.br" checked id="ss1"></input>
<label for="ss1" title="Pesquisar www.1bit.com.br"><font size="-2" color="black">www.1bit.com.br</font></label></td>
</tr>
</table>
<label for="sbb" style="display: none">Enviar formulÃ¡rio de pesquisa</label>
<input type="submit" name="sa" value="Pesquisar" id="sbb"></input>
<input type="hidden" name="client" value="pub-2589539519655496"></input>
<input type="hidden" name="forid" value="1"></input>
<input type="hidden" name="ie" value="ISO-8859-1"></input>
<input type="hidden" name="oe" value="ISO-8859-1"></input>
<input type="hidden" name="cof" value="GALT:#0066CC;GL:1;DIV:#999999;VLC:336633;AH:center;BGC:FFFFFF;LBGC:FFFFFF;ALC:0066CC;LC:0066CC;T:000000;GFNT:666666;GIMP:666666;LH:50;LW:120;L:http://www.1bit.com.br/images/logo_novo_2.png;S:http://;FORID:1"></input>
<input type="hidden" name="hl" value="pt"></input>
</td></tr></table>
</form>
<!-- SiteSearch Google -->
<br>

<br>
<br>
<center>

<br><br><br>

<!--
<a href="http://whos.amung.us/show/xopqoakh"><img src="http://whos.amung.us/cwidget/xopqoakh/fffffff6915a.png" alt="page counter" width="81" height="29" border="0" /></a>
-->

</center>



<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
          </td>
          <td valign="top">
<div class="content">
<h4><a href="content.1bit/weblog" style="text-decoration:none;">Rodrigo Strauss :: Blog</a></h4>
<table border="0">
<tr>
<!-- 
<td width="60">

<a style="text-decoration:none;" href="../../weblog_rss.1bit"><img src="../../../images/xml.gif" border="0"/></a>
</td>
-->

<td>



</td>

<td>




</td>

<td align="right">




<!--

<script type="text/javascript">
google_ad_client = "pub-2589539519655496";
google_ad_width = 468;
google_ad_height = 15;
google_ad_format = "468x15_0ads_al";
google_ad_channel = "";
google_color_border = "FFFFFF";
google_color_bg = "FFFFFF";
google_color_link = "FF5000";
google_color_text = "000000";
google_color_url = "FF5000";
</script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
-->






</td>
</tr>
</table>
<br>
<h5>Tutorial de STL, parte 6: Functors</h5><p>Functors (ou function objects) são objetos que podem ser chamados como funções. No C++, você pode sobrecarregar o operador de chamada de função - operator() - e permitir que um objeto se comporte de forma bem parecida com uma função. A grande vantagem de um objeto em relação a uma função é que o primeiro pode guardar estados diferentes usando instâncias diferentes. Um função pode guardar estado, mas esse estado é único para todos que chamam essa função. Tudo fica mais simples com um exemplo de código:</p>

<div class="code"><pre><span class="keyword">class </span>FunctorString
{
  std::string m_str;
<span class="keyword">public</span>:
  FunctorString(<span class="keyword">const</span> std::string&amp; str) : m_str(str)
  {}
  <span class="keyword">bool</span> <span class="keyword">operator</span> ()(<span class="keyword">const</span> std::string&amp; str)
  {
    <span class="keyword">return</span> m_str == str;
  }
};

&nbsp;
<span class="keyword">int</span> main()
{
  FunctorString comparaComLaranja(<span class="literal">"laranja"</span>), comparaComBanana(<span class="literal">"banana"</span>);
&nbsp;
  <span class="comment">//
</span>  <span class="comment">// todos chamados como função, comparando com
</span>  <span class="comment">// coisas diferentes
</span>  <span class="comment">//

</span>  std::cout &lt;&lt; comparaComLaranja(<span class="literal">"maçã"</span>) &lt;&lt; std::endl; <span class="comment">// não
</span>  std::cout &lt;&lt; comparaComLaranja(<span class="literal">"banana"</span>) &lt;&lt; std::endl; <span class="comment">// também não
</span>  std::cout &lt;&lt; comparaComLaranja(<span class="literal">"laranja"</span>) &lt;&lt; std::endl; <span class="comment">// agora sim


</span>&nbsp;&nbsp;std::cout &lt;&lt; comparaComBanana(<span class="literal">"maçã"</span>) &lt;&lt; std::endl; <span class="comment">// não
</span>   std::cout &lt;&lt; comparaComBanana(<span class="literal">"pera"</span>) &lt;&lt; std::endl; <span class="comment">// também não
</span>  &nbsp;std::cout &lt;&lt; comparaComBanana(<span class="literal">"banana"</span>) &lt;&lt; std::endl; <span class="comment">// agora sim

</span>}</pre></div>

<p>Note que o FunctorString pode ser chamado exatamente como uma função, mas criando diferentes instâncias você pode criar comportamentos diferentes. Isso é muito interessante para quando uma função que deve ser rodada sobre uma seqüência STL não é trivial. Exemplo: o algoritmo for_each chama uma função (ou functor) para cada item da sequência. Caso queiramos elevar todos os itens a uma determinada potência x, não podemos usar uma função, pois para cada potência diferente seria necessário criar outra função (esqueça a gambiarra da variável global). Usando um Functor isso fica fácil, é só criar diversas instâncias com a potência diferente.</p>

<p>Functors funcionam bem também para containers com objetos, onde geralmente as comparações ou ações sobre eles não é trivial, quase sempre exigem manipulação de acesso à itens. Além disso, é intessante notar que os algoritmos da STL não aceitam ponteiros de função, mas sim parâmetros cujos tipos são dados de acordo com um template. Ou seja, qualquer coisa que puder ser chamada como uma função - seja um função isolada, função estática de uma classe ou um functor - serve. É o que chamamos de duck typing: se anda como um pato e faz quack como um pato, deve ser um pato.</p>

<p>Segue um código grande, que usa Functors e tem também um exemplo de uso de templates para substituir os Functors por templates no caso do estado do nosso suposto functor ser um tipo:</p>

<div class="code">
<pre>&nbsp;<span class="keyword">
#include</span> <span class="literal">"stdafx.h"</span><span class="keyword">
#include</span> &lt;assert.h><span class="keyword">
#include</span> &lt;vector><span class="keyword">
#include</span> &lt;string><span class="keyword">

#include</span> &lt;iostream>
&nbsp;
<span class="comment">//
</span><span class="comment">// Código longo mas interessante para demonstrar 
</span><span class="comment">// programação genérica. Pretendo usar essa hierarquia
</span><span class="comment">// para futuras explanações
</span><span class="comment">//
</span>&nbsp;
<span class="keyword">struct</span> ProgrammingLanguage
{
  std::string name;
  std::string creator;
  <span class="comment">// preciso disso para o dynamic_cast...
</span>  <span class="keyword">virtual</span> ~ProgrammingLanguage(){} 
};

&nbsp;
<span class="keyword">struct</span> CompiledProgrammingLanguage : <span class="keyword">public</span> ProgrammingLanguage
{
  <span class="keyword">struct</span> Compiler
  {
    std::string name;
    <span class="keyword">bool</span> isOpenSource;
  };
&nbsp;
  std::vector&lt;Compiler> availableCompilers;
};

&nbsp;
<span class="keyword">struct</span> NativeCompiledProgrammingLanguage  : <span class="keyword">public</span> CompiledProgrammingLanguage
{
  <span class="keyword">bool</span> hasOptimizer;
};
&nbsp;
<span class="keyword">enum</span> JitModel
{
  Everything,
  HotFunctions
};
&nbsp;
<span class="keyword">struct</span> ByteCodeCompiledProgrammingLanguage : <span class="keyword">public</span> CompiledProgrammingLanguage
{
  <span class="keyword">bool</span> hasJit;
  JitModel jitModel;
};

&nbsp;
<span class="keyword">struct</span> InterpretedLanguage : <span class="keyword">public</span> ProgrammingLanguage
{
  <span class="keyword">bool</span> hasConsole;
};
&nbsp;
&nbsp;
<span class="keyword">void</span> LoadLanguages(std::vector&lt;ProgrammingLanguage*>* pLanguages)
{
  <span class="comment">//

</span>  <span class="comment">// Alerta de didática:
</span>  <span class="comment">// EU SOU CONTRA alocar memória em ponteiro raw, sem
</span>  <span class="comment">// gerenciamento. A primeira versão desse código usava
</span>  <span class="comment">// boost:shared_ptr, mas tornava os functors mais 
</span>  <span class="comment">// complicados por causa de adaptors e coisas assim.
</span>  <span class="comment">//
</span>&nbsp;
  <span class="comment">//
</span>  <span class="comment">// Python

</span>  <span class="comment">//
</span>  InterpretedLanguage* python = <span class="keyword">new</span> InterpretedLanguage();
  python->name = <span class="literal">"Python"</span> ;
  python->creator = <span class="literal">"Guido van Rossum"</span>;
  python->hasConsole = <span class="keyword">true</span>;
  pLanguages->push_back(python);
&nbsp;
  <span class="comment">//

</span>  <span class="comment">// VBScript
</span>  <span class="comment">//
</span>  InterpretedLanguage* vbScript = <span class="keyword">new</span> InterpretedLanguage();
  vbScript->name = <span class="literal">"VBScript"</span> ;
  vbScript->creator = <span class="literal">"??"</span>;
  vbScript->hasConsole = <span class="keyword">false</span>;
  pLanguages->push_back(vbScript);
&nbsp;

  <span class="comment">//
</span>  <span class="comment">// JavaScript
</span>  <span class="comment">//
</span>  InterpretedLanguage* javaScript = <span class="keyword">new</span> InterpretedLanguage();
  javaScript->name = <span class="literal">"JavaScript"</span>;
  javaScript->creator = <span class="literal">"??"</span>;
  javaScript->hasConsole = <span class="keyword">false</span>;
  pLanguages->push_back(javaScript);

&nbsp;
  <span class="comment">//
</span>  <span class="comment">// Java
</span>  <span class="comment">//
</span>  ByteCodeCompiledProgrammingLanguage* java = <span class="keyword">new</span> ByteCodeCompiledProgrammingLanguage();
  java->name = <span class="literal">"Java"</span> ;
  java->creator = <span class="literal">"James Gosling"</span>;
  java->hasJit = <span class="keyword">true</span>;
  java->jitModel = HotFunctions; <span class="comment">// Me corrijam se estou errado

</span>&nbsp;
  CompiledProgrammingLanguage::Compiler javaCompiler;
  javaCompiler.isOpenSource = <span class="keyword">true</span>; <span class="comment">// Já foi liberado, né?
</span>  javaCompiler.name = <span class="literal">"javac"</span>;
  java->availableCompilers.push_back(javaCompiler);
&nbsp;
  pLanguages->push_back(java);
&nbsp;
  <span class="comment">//
</span>  <span class="comment">// C#

</span>  <span class="comment">//
</span>  ByteCodeCompiledProgrammingLanguage* cSharp = <span class="keyword">new</span> ByteCodeCompiledProgrammingLanguage();
  cSharp->name = <span class="literal">"C#"</span>; 
  cSharp->creator = <span class="literal">"Anders Hejlsberg"</span>;
  cSharp->hasJit = <span class="keyword">true</span>;
  cSharp->jitModel = Everything;
&nbsp;
  CompiledProgrammingLanguage::Compiler microsoftCsCompiler;
  microsoftCsCompiler.isOpenSource = <span class="keyword">false</span>;
  microsoftCsCompiler.name = <span class="literal">"csc"</span>;
  cSharp->availableCompilers.push_back(microsoftCsCompiler);

&nbsp;
  pLanguages->push_back(cSharp);
&nbsp;
  <span class="comment">//
</span>  <span class="comment">// C++
</span>  <span class="comment">//
</span>  NativeCompiledProgrammingLanguage* cPlusPlus = <span class="keyword">new</span> NativeCompiledProgrammingLanguage();
  cPlusPlus->name = <span class="literal">"C++"</span>; 
  cPlusPlus->creator = <span class="literal">"Bjarne Stroustrup"</span>;

&nbsp;
  CompiledProgrammingLanguage::Compiler gcc;
  gcc.isOpenSource = <span class="keyword">true</span>;
  gcc.name = <span class="literal">"GNU C++"</span>;
  cPlusPlus->availableCompilers.push_back(gcc);
&nbsp;
  CompiledProgrammingLanguage::Compiler vc;
  vc.isOpenSource = <span class="keyword">false</span>;
  vc.name = <span class="literal">"Visual C++"</span>;
  cPlusPlus->availableCompilers.push_back(vc);
&nbsp;
  pLanguages->push_back(cPlusPlus);

&nbsp;
  <span class="comment">//
</span>  <span class="comment">// Se sua linguagem preferida não está aqui
</span>  <span class="comment">// não fique triste, nada pessoal..
</span>  <span class="comment">//
</span>}
&nbsp;
&nbsp;
<span class="comment">//
</span><span class="comment">// Isso não precisa ser um functor, porque
</span><span class="comment">// como vamos filtrar de acordo com o tipo,
</span><span class="comment">// um template já guardar estado do tipo com
</span><span class="comment">// o qual ele foi instânciado

</span><span class="comment">//
</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T>
<span class="keyword">bool</span> IsLanguageType(ProgrammingLanguage* p)
{
  <span class="comment">//
</span>  <span class="comment">// isso não tem efeito em runtime, mas garante
</span>  <span class="comment">// que o tipo que você está usando herda de
</span>  <span class="comment">// ProgrammingLanguage
</span>  <span class="comment">//

</span>  <span class="keyword">static_cast</span>&lt;ProgrammingLanguage*>((T*)NULL); 
&nbsp;
  <span class="keyword">return</span> <span class="keyword">dynamic_cast</span>&lt;<span class="keyword">const</span> T*>(p) != NULL;
}
&nbsp;
<span class="keyword">template</span>&lt;<span class="keyword">typename</span> TDump, <span class="keyword">typename</span> TIterator>

<span class="keyword">void</span> DumpLanguagesByType(TIterator first, TIterator last, std::string message)
{
  std::cout &lt;&lt; std::endl
    &lt;&lt; message &lt;&lt; std::endl 
    &lt;&lt; std::string(message.size(), <span class="literal">'='</span>) &lt;&lt; std::endl;
&nbsp;
  <span class="keyword">for</span>( ; ; )
  {
    <span class="comment">//

</span>    <span class="comment">// acha o próximo item com esse 
</span>    <span class="comment">// determinado tipo
</span>    <span class="comment">//
</span>    first = std::find_if(
      first, 
      last, 
      &amp;IsLanguageType&lt;TDump>);
&nbsp;
    <span class="keyword">if</span>(first == last)
      <span class="keyword">break</span>; <span class="comment">// cabô

</span>&nbsp;
    <span class="comment">// só pra garantir...
</span>    assert(<span class="keyword">dynamic_cast</span>&lt;TDump*>((*first)));
&nbsp;
    <span class="comment">// dump
</span>    std::cout &lt;&lt; (*first)->name &lt;&lt; std::endl;
&nbsp;

    ++first;
  }
&nbsp;
  <span class="keyword">return</span>;
}
&nbsp;
<span class="comment">//
</span><span class="comment">// Isso é um functor, um objeto que pode ser
</span><span class="comment">// chamado como uma função. A vantagem é que um 
</span><span class="comment">// objeto guarda estado, o que nos permite salvar
</span><span class="comment">// o nome que deve ser procurado nas chamadas 
</span><span class="comment">// seguintes
</span><span class="comment">//
</span><span class="keyword">class </span>FindLanguageByName
{
  std::string m_name;
<span class="keyword">public</span>:
  FindLanguageByName(<span class="keyword">const</span> std::string&amp; name) : m_name(name)
  {}

&nbsp;
  <span class="keyword">bool</span> <span class="keyword">operator</span>()(ProgrammingLanguage* p)
  {
    <span class="keyword">return</span> p->name == m_name;
  }
};
&nbsp;
<span class="keyword">void</span> FreeLanguage(ProgrammingLanguage* p)
{
  <span class="comment">//
</span>  <span class="comment">// caso tenhamos mais membros a serem liberados,
</span>  <span class="comment">// centralizamos o código de limpeza aqui

</span>  <span class="comment">//
</span>  <span class="keyword">delete</span> p;
}
&nbsp;
<span class="keyword">int</span> main()
{
  <span class="keyword">typedef</span> std::vector&lt;ProgrammingLanguage*> LanguagesVector;
  LanguagesVector languages;
&nbsp;
  LoadLanguages(&amp;languages);

&nbsp;
  <span class="comment">//
</span>  <span class="comment">// encontra as linguagens interpretadas. Nessa caso não usamos
</span>  <span class="comment">// functors porque nossa função é um template. Note que como
</span>  <span class="comment">// vamos diferenciar pelo tipo, usaremos um tipo como parâmetro.
</span>  <span class="comment">// tipo como parâmetro = template
</span>  <span class="comment">//
</span>  std::cout &lt;&lt; <span class="literal">"Linguagens interpretadas"</span> &lt;&lt; std::endl 
&lt;&lt; <span class="literal">"========================"</span> &lt;&lt; std::endl;

&nbsp;
  <span class="keyword">for</span>(LanguagesVector::iterator iLanguage = languages.begin() ; ; )
  {
    iLanguage = std::find_if(
      iLanguage, 
      languages.end(), 
      &amp;IsLanguageType&lt;InterpretedLanguage>);
&nbsp;
    <span class="keyword">if</span>(iLanguage == languages.end())
      <span class="keyword">break</span>; <span class="comment">// cabô
</span>&nbsp;
    std::cout &lt;&lt; (*iLanguage)->name &lt;&lt; std::endl;

&nbsp;
    ++iLanguage;
  }
&nbsp;
  <span class="comment">//
</span>  <span class="comment">// encapusulei o código acima em uma função template.
</span>  <span class="comment">// Agora vou fazer isso com o resto dos tipos.
</span>  <span class="comment">//
</span>  DumpLanguagesByType&lt;NativeCompiledProgrammingLanguage>(
    languages.begin(), 
    languages.end(),
    <span class="literal">"Linguagens compiladas para o native code do processador"</span>);

&nbsp;
  DumpLanguagesByType&lt;ByteCodeCompiledProgrammingLanguage>(
    languages.begin(), 
    languages.end(),
    <span class="literal">"Linguagens compiladas para byte code"</span>);
&nbsp;
  <span class="comment">//
</span>  <span class="comment">// agora vou procurar a linguagem por nome usando um functor.
</span>  <span class="comment">// Note que a vantagem é que classe FindLanguageByName guarda
</span>  <span class="comment">// a string "Python" para ser usada toda ver que o find_if
</span>  <span class="comment">// chamá-la para fazer a comparação

</span>  <span class="comment">//
</span>  LanguagesVector::iterator iLanguage = 
    std::find_if(languages.begin(), languages.end(), FindLanguageByName(<span class="literal">"Python"</span>));
&nbsp;
  std::cout &lt;&lt; std::endl &lt;&lt; 
    <span class="literal">"Python"</span> &lt;&lt; (iLanguage != languages.end() ? 
<span class="literal">""</span> : <span class="literal">" não"</span>) &lt;&lt; <span class="literal">" encontrado."</span> &lt;&lt; std::endl;

&nbsp;
  <span class="comment">//
</span>  <span class="comment">// desalocando tudo
</span>  <span class="comment">//
</span>  for_each(languages.begin(), languages.end(), &amp;FreeLanguage);
&nbsp;
  languages.clear();
&nbsp;
  <span class="keyword">return</span> 0;
}</pre></div><br><p class="datetime">Em 27/03/2007 17:03, por  Rodrigo Strauss </p>
</div>
          </td>
        </tr>



<tr>
<td class="topmenu"></td>
<td>
<br>
<center>

<script type="text/javascript"><!--
google_ad_client = "pub-2589539519655496";
google_ad_width = 728;
google_ad_height = 90;
google_ad_format = "728x90_as";
google_ad_type = "text";
google_ad_channel = "";
google_color_border = "FFFFFF";
google_color_bg = "FFFFFF";
google_color_link = "FF5000";
google_color_text = "000000";
google_color_url = "FF5000";
google_ui_features = "rc:6";
//-->
</script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>

</center>
</td>
</tr>

<tr>
 <td class="topmenu"></td>
 <td>
  <table style="margin: 0px" cellspacing="0" cellpadding="0" width="100%" border="0">
   <tr>
    <td><img src="../../../images/rebarba3.png"></td>
    <td align="right"><img src="../../../images/rebarba4.png"></td>
   </tr>
  </table>
 </td>
</tr>

<tr><td class="topmenu">&nbsp;</td><td class="topmenu">&nbsp;</td></tr>
<tr><td class="topmenu">&nbsp;</td><td>
<table style="MARGIN: 0px" cellspacing="0" cellpadding="0" width="100%" border="0">
            <tr>
              <td><img src="../../../images/rebarba1.png"></td>
              <td align="right"><img src="../../../images/rebarba2.png"></td>
              </tr>
            </table>
</td>
</tr>
 <tr><td class="topmenu">&nbsp;</td>
<td>

<div class="content">
<a name="comments"></a><h5>Comentários</h5><div class="post_comment">
<a name="2331"></a><B>Daniel</B>  | em 30/07/2008 | <a rel="nofollow" href="content.1bit/weblog/stl_tutorial_6#2331">#</a><br>
Caro Rodrigo,<br><br>Tenho uma dúvida quanto ao código acima: a construção<br><br>void LoadLanguages(std::vector&lt;ProgrammingLanguage*&gt;* pLanguages)<br><br>poderia ser substituída por<br><br>void LoadLanguages(std::vector&lt;ProgrammingLanguage*&gt;::iterator pLanguages)<br><br><br>?????<br><br><br>Obrigado
</div>
<div class="post_comment_strauss">
<a name="2334"></a><B>Rodrigo Strauss</B>  | <a rel="nofollow" href="http://www.1bit.com.br">website</a> | em 03/08/2008 | <a rel="nofollow" href="content.1bit/weblog/stl_tutorial_6#2334">#</a><br>
No contexto acima, não. O iterator aponta para um item do container, e não para o container em si.
</div>

<h5>Algo a dizer?</h5>
<script language="JavaScript">
function setCookie(name, value, expires, path, domain, secure) {
  var curCookie = name + "=" + escape(value) +
      ((expires) ? "; expires=" + expires.toGMTString() : "") +
      ((path) ? "; path=" + path : "") +
      ((domain) ? "; domain=" + domain : "") +
      ((secure) ? "; secure" : "");
  document.cookie = curCookie;
}

function getCookie(name) {
  var dc = document.cookie;
  var prefix = name + "=";
  var begin = dc.indexOf("; " + prefix);
  if (begin == -1) {
    begin = dc.indexOf(prefix);
    if (begin != 0) return null;
  } else
    begin += 2;
  var end = document.cookie.indexOf(";", begin);
  if (end == -1)
    end = dc.length;
  return unescape(dc.substring(begin + prefix.length, end));
}

function deleteCookie(name, path, domain) {
  if (getCookie(name)) {
    document.cookie = name + "=" +
    ((path) ? "; path=" + path : "") +
    ((domain) ? "; domain=" + domain : "") +
    "; expires=Thu, 01-Jan-70 00:00:01 GMT";
  }
}

function CheckName()
{
  if(comment_form.name.value == '')
  {
    alert('Você esqueceu de informar o seu nome...');
    comment_form.name.focus();
    
    return false;
  }

  if(comment_form.comment.value == '')
  {
    alert('O que você acha de escrever o comentário antes de tentar enviá-lo?');
    comment_form.comment.focus();
    
    return false;
  }

  var now = new Date();

  // um ano
  now.setTime(now.getTime() + 365 * 24 * 60 * 60 * 1000);
  setCookie("name", comment_form.name.value, now);
  setCookie("email", comment_form.email.value, now);
  setCookie("link", comment_form.link.value, now);
  setCookie("hideemail", comment_form.hideemail.value, now);

  return true;
}

</script>
<form name="comment_form" method="POST" action="/comment.html" onsubmit="return CheckName();">
<input type="hidden" name="article" value="weblog/1175025805"/>

Nome:<br/>
<input type="text" name="name" style="width: 250px;"/><br/>
<br/>

Site:<br/>
<input type="text" name="link" style="width: 250px;" /><br/>
<br/>

E-mail:<br/>
<input type="text" name="email" style="width: 250px;" />
<br/><br/>

Escreva o número vinte e seis:<br/>
<input type="text" name="idade" style="width: 250px;" />
<br/><br/>

<input type="checkbox" name="hideemail"/>&nbsp;Não mostre meu e-mail no site, não serve pra nada mesmo...
<br/><br/>

Comentário<br/>
<textarea style="WIDTH: 500px; HEIGHT: 300px" name="comment" rows="18" cols="50"></textarea><br/>
<br/>
<input type="submit" value="Dizer"/><br/><br/><br/>
<div style="width:500px;font-size:8pt;">
<b>Os comentários devem ser sobre assuntos relativos ao post</b>, eu provavelmente apagarei comentários totalmente offtopic. Se quiser me enviar uma mensagem, use o <a href="../../../content.1bit/contact">formulário de contato</a>. E não esqueça: isso é um site pessoal e eu me reservo o direito de apagar qualquer comentário ofensivo ou inapropriado.
</div>
</form>

<script language="JavaScript">
// cookie de nome
var name = getCookie("name");
if (name && name != 'null')
{
  comment_form.name.value = name;
  comment_form.email.value = getCookie("email");
  comment_form.link.value = getCookie("link");
  comment_form.hideemail.value = getCookie("hideemail");
}

</script>

</div>

</td></tr>



















<tr>
          <td class="topmenu"></td>
          <td>
          <table style="margin: 0px" cellspacing="0" cellpadding="0" width="100%" border="0">
            <tr>
              <td><img src="../../../images/rebarba3.png" alt="rebarba"></td>
              <td align="right"><img src="../../../images/rebarba4.png" alt="rebarba"></td>
            </tr>
          </table>
          </td>
        </tr>

        <tr>
          <td class="topmenu">&nbsp;</td>
          <td class="topmenu" height="25" align="right" style="color:#999999;">
::::
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          </td>
        </tr>
    </table>
  </body>
</html>
