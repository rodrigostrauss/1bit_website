

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
<meta charset="utf-8">

<META NAME="author" CONTENT="Rodrigo Strauss">
<META NAME="ROBOTS" CONTENT="ALL">
    <title>Usando Win32 API para otimizar o I/O, parte 6  ::::  Rodrigo Strauss :: www.1bit.com.br</title>
    <link href="../../../1bit.css" type="text/css" rel="stylesheet">
    <link rel="alternate" type="text/xml" title="RSS" href="../../../weblog_rss.1bit">
</head>
  <body style="margin:0px 0px 0px 0px" bgcolor="#FFFFFF">
    <table cellspacing="0" cellpadding="0" width="100%" border="0">
        <tr>
          <td class="header" valign="middle" bgcolor="#ffffff" height="77" colspan="2">&nbsp;
<a href="../../../"><img src="../../../images/logo_novo_2.png" border="0" alt="logo" /></a>

          </td>
        </tr>
        <tr>
          <td class="topmenu"></td>
          <td class="topmenu" align="right" height="30">
		    <a class="top_menu_link" href="../../../content.1bit/contact">Contato</a> 
			<span class="menusep">|</span>
            
            <a class="top_menu_link" href="../../../content.1bit/about">Sobre...</a>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          </td>
        </tr>
        <tr>
          <td class="topmenu"></td>
          <td>
          <table style="MARGIN: 0px" cellspacing="0" cellpadding="0" width="100%" border="0">
            <tr>
              <td><img src="../../../images/rebarba1.png" alt="rebarba"></td>
              <td align="right"><img src="../../../images/rebarba2.png" alt="rebarba"></td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td class="menu" valign="top" width="175">

<div class="left_menu_section">
 <h2><a href="../../../#artigos" style="text-decoration:none;">Artigos</a></h2>
</div>

<div class="left_menu_section">
 <h2><a href="../../../content.1bit/weblog_archive" style="text-decoration:none;">Blog</a></h2>
</div>

<div class="left_menu_section">
 <h2><a href="../../../content.1bit/opensource" style="text-decoration:none;">Open Source</a></h2>
</div>

<!-- 
<div class="left_menu_section">
 <h2><a href="content.1bit/aulas" style="text-decoration:none;">Aulas online (ou não) </a></h2>
</div>
-->


<br>
<br>
<br>
<center>

<!--
<a href="http://whos.amung.us/show/xopqoakh"><img src="http://whos.amung.us/cwidget/xopqoakh/fffffff6915a.png" alt="page counter" width="81" height="29" border="0" /></a>
-->

</center>



<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
          </td>
          <td valign="top">
<div class="content">
<h4><a href="../../../content.1bit/weblog_archive" style="text-decoration:none;">Rodrigo Strauss :: Blog</a></h4>
<table border="0">
<tr>
<!-- 
<td width="60">

<a style="text-decoration:none;" href="../../weblog_rss.1bit"><img src="../../../images/xml.gif" border="0"/></a>
</td>
-->

<td>



</td>

<td>




</td>

<td align="right">




<!--

<script type="text/javascript">
google_ad_client = "pub-2589539519655496";
google_ad_width = 468;
google_ad_height = 15;
google_ad_format = "468x15_0ads_al";
google_ad_channel = "";
google_color_border = "FFFFFF";
google_color_bg = "FFFFFF";
google_color_link = "FF5000";
google_color_text = "000000";
google_color_url = "FF5000";
</script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
-->






</td>
</tr>
</table>
<br>
<h5>Usando Win32 API para otimizar o I/O, parte 6</h5><p><a href="../../../content.1bit/weblog/otimizacao_faz_diferenca">Parte Zero</a>

&nbsp;&nbsp;&nbsp;
<a href="../../../content.1bit/weblog/otimizacao_io_1">Parte 1</a>
&nbsp;&nbsp;&nbsp;
<a href="../../../content.1bit/weblog/otimizacao_io_2">Parte 2</a>
&nbsp;&nbsp;&nbsp;
<a href="../../../content.1bit/weblog/otimizacao_io_3">Parte 3</a>
&nbsp;&nbsp;&nbsp;
<a href="../../../content.1bit/weblog/otimizacao_io_4">Parte 4</a>
&nbsp;&nbsp;&nbsp;
<a href="../../../content.1bit/weblog/otimizacao_io_5">Parte 5</a>
&nbsp;&nbsp;&nbsp;
<a href="../../../content.1bit/weblog/midlparser_source">Fontes do parser</a>
</p>


<p>Depois de turbulências, <a href="http://thespoke.net/blogs/alfred_myers/archive/2005/09/26/OndeMoraraStrauss.aspx">mudanças de endereço</a> e <a href="../../../content.1bit/weblog/wtf">besteiras</a>, é hora de dar continuidade à série sobre otimização de desempenho de I/O. Nos nossos exemplos, eu usei um interpretador de IDL que deve ler o conteúdo do arquivo em questão e vários <i>imports</i>, para mostrar o grau de otimização que é possível usando a API Win32 ao invés da runtime do C++.</p>

<p>Só para esclarecer: a runtime do C++ não é lenta, é até que <a href="../../../content.1bit/weblog/otimizacao_faz_diferenca">bastante rápida</a>. O grande negócio é que qualquer abstração deixa o código mais lento, já que são mais camadas intermediárias para fazer o que realmente se quer, e mais código será rodado para fazer a mesma coisa. É esse o motivo pelo qual, na esmagadora maioria das vezes, um programa feito em Visual C++ <a href="../../../content.1bit/weblog/mais_um_benchmark">é bem mais rápido do que um feito em .NET</a> ou Java. Além de abstrair a API nativa do sistema operacional - que a runtime do C++ também faz - o Java e o .NET <a href="http://en.wikipedia.org/wiki/Virtual_machine">abstraem também a arquitetura do computador</a> onde o programa está rodando. A API nativa do Windows é a Win32, qualquer coisa que não use a API diretamente (VB6, Delphi, Java, .NET, [coloque-algo-que-não-seja-C-e-C++-puros-aqui] fica sempre mais lento do que usar a API diretamente. O fato é que as vezes a diferença é muito pequena (como no caso do Delphi) e não vale a pena o trabalho de usar Win32 (que não é pequeno). Na realidade, hoje todo mundo usa alguma abstração sobre Win32, seja ela uma grande abstração (.NET) ou uma pequena abstração (MFC).

<p>Nessa nossa otimização, iremos usar um recurso do Windows chamado <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/fileio/fs/file_mapping.asp">File Mapping</a>. Esse recurso permite mapear um trecho de um arquivo diretamente na memória, e a medida que a memória é lida, o conteúdo do arquivo é colocado nela automaticamente. Para o programa, é como se o conteúdo do arquivo já estivesse na memória, mas na realidade o arquivo é lido a medida que o programa acessa essa memória. Isso evita buffers intermediários, e no final das contas, é mais simples do que alocar memória, ler o arquivo e depois tratar.</p>

<p>O File Mapping é implementado em kernel mode como um recurso chamado 
<a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/kmarch/hh/kmarch/MemMgmt_87e8805d-06df-443b-b678-ae36fe30d511.xml.asp">Section</a>. Quando você mapeia um trecho do arquivo na memória (usando MapViewOfFile em user mode), o arquivo não é lido para memória na hora. As páginas de memória são marcadas como inválidas, o que faz com o que sejá disparada uma exceção quando essa memória é acessada. 	Essa exceção é tratada pelo Memory Manager, que faz a leitura do trecho acessado do arquivo para essa memória, marca a página como válida e retorna o controle para o programa, que agora terá o conteúdo esperado do arquivo nessa memória. O File Mapping também pode ser usado para compartilhar memória entre os programas. O Windows usa esse recurso para carregar executáveis e DLLs na memória, o que faz com que o conteúdo de uma DLL só seja carregado uma vez para todos os processos que estão usando-a.</p>

<p>Para simplificar o uso do File Mapping no nosso interpretador e para isolar um pouco o código Win32 do nosso código, criei uma classe simples para tratar o File Mapping:</p>

<style type="text/css">
.code_comment { color: rgb(0,128,0) } 
.keyword { color: rgb(0,0,255) } 
.string { color: rgb(255,0,0) } 
</style>

<!--
C++ syntax coloring of this page was made by code@web program.
free download of code@web at
http://planeta.terra.com.br/informatica/thiago_adams/
thanks for using it, Thiago R. Adams ( thiago_adams@hotmail.com )
-->
<div class="code">
<pre>
<span class="code_comment">//
</span><span class="code_comment">// Classe que mapeia um arquivo inteiro na mem&oacute;ria
</span><span class="code_comment">// usando FileMapping
</span><span class="code_comment">//
</span><span class="code_comment">// Rodrigo Strauss - http://www.1bit.com.br
</span><span class="code_comment">//
</span><span class="keyword">class</span> Win32FileMapping
{
   HANDLE m_hFile, m_hFileMapping;
   DWORD m_dwFileSize;
   <span class="keyword">void</span>* m_p;

   <span class="keyword">void</span> Clean()
   {
      m_hFileMapping = NULL;
      m_hFile = INVALID_HANDLE_VALUE;
      m_p = NULL;
      m_dwFileSize = 0;
   }

<span class="keyword">public</span>:
   Win32FileMapping()
   {
      Clean();
   }

   ~Win32FileMapping()
   {
      Free();
   }

   <span class="keyword">bool</span> IsValid()
   {
      <span class="keyword">return</span> m_p &amp;&amp; m_hFileMapping &amp;&amp; m_hFile != INVALID_HANDLE_VALUE;
   }

   <span class="keyword">void</span> Free()
   {
      <span class="keyword">if</span>(m_p)
         UnmapViewOfFile(m_p);

      <span class="keyword">if</span>(m_hFileMapping)
         CloseHandle(m_hFileMapping);

      <span class="keyword">if</span>(m_hFile != INVALID_HANDLE_VALUE)
         CloseHandle(m_hFile);

      Clean();
   }

   <span class="code_comment">//
</span>   <span class="code_comment">// Essa fun&ccedil;&atilde;o mapeia o arquivo inteiro na mem&oacute;ria
</span>   <span class="code_comment">//
</span>   <span class="keyword">bool</span> MapFile(<span class="keyword">const</span> <span class="keyword">char</span>* fileName)
   {
      Free();

      m_hFile = CreateFile(fileName, 
                           GENERIC_READ, 
                           FILE_SHARE_READ, 
                           NULL, 
                           OPEN_EXISTING, 
                           NULL, 
                           NULL);

      <span class="keyword">if</span>(m_hFile == INVALID_HANDLE_VALUE)
         <span class="keyword">return</span> <span class="keyword">false</span>;

      m_dwFileSize = GetFileSize(m_hFile, NULL);

      m_hFileMapping = CreateFileMapping(m_hFile, 
                                         NULL,
                                         PAGE_READONLY, 
                                         0,
                                         0, 
                                         NULL);

      <span class="keyword">if</span>(m_hFileMapping == NULL)
&nbsp;&nbsp;  {
&nbsp;&nbsp;&nbsp;&nbsp; Free();
         <span class="keyword">return</span> <span class="keyword">false</span>;
&nbsp;&nbsp;  }

      m_p = MapViewOfFile(m_hFileMapping, FILE_MAP_READ, 0, 0, 0);

      <span class="keyword">return</span> <span class="keyword">true</span>;
   }

   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
   T GetStart()
   {
      <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;T&gt;(m_p);
   }

   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
   T GetEnd()
   {
      <span class="keyword">if</span>(!m_dwFileSize)
         <span class="keyword">return</span> NULL;

      <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;T&gt;( ((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)m_p) + m_dwFileSize );
   }
};
</pre>
</div>

<p>Essa classe mapeia o arquivo inteiro na memória, e retorna os ponteiros de início de de fim através das funções template GetStart<T>() e GetEnd<T>(). Note que o GetEnd<T>() retorna um ponteiro para o primeiro T depois do fim do arquivo. Esse o mesmo conceito usado pelos containers STL, onde o end() retorna um elemento inválido após o último item. O último item de um container é [container.end() - 1] (se, e somente se container.begin() != container.end())</p>

<p>O boost::tokenizer tem duas opções de inicialização: passar uma string com o conteúdo a ser interpretado, ou um iterator inicial e um iterator final. No nosso caso, o iterator inicial é GetStart<T>() e o final GetEnd<T>(). Não se esqueça que em STL, o conceito iterator é uma generalização de um ponteiro: um objeto que aponte para outro objeto (ou seja, sobrecarregue o operador *) e que (não necessariamente) possa ser incrementado e decrementado (operadores ++ e --) para acessar outros itens (para mais detalhes veja a <a href="http://www.sgi.com/tech/stl/Iterators.html">documentação no site da SGI</a>). Então um ponteiro É um iterator, o que resolve o nosso problema de uma forma bem simples.</p>

<p>Vamos ao código (é por isso que você está lendo isso, não é?):</p>

<div class="code">
<pre>
<span class="keyword">void</span> MidlParser::ParseMidlFile(<span class="keyword">const</span> <span class="keyword">char</span>* fileName)
{
   ...
   Win32FileMapping fileMapping;


   <span class="keyword">if</span>(m_bParseAsImportFile)
   {
      <span class="code_comment">//
</span>      <span class="code_comment">// tenta abrir o imported file nas pastas de include
</span>      <span class="code_comment">//
</span>&nbsp;&nbsp;  <span class="keyword">for</span>(vector&lt;string&gt;::const_iterator i = m_IncludePaths.begin() ;
            i != m_IncludePaths.end() ; 
            ++i)
      {
         string str;

         str = *i + fileName;

         fileMapping.MapFile(str.c_str());

         <span class="keyword">if</span>(fileMapping.IsValid())
            <span class="keyword">break</span>;
      }

      <span class="keyword">if</span>(!fileMapping.IsValid())
         <span class="keyword">throw</span> ParseException(string(<span class="string">&quot;error opening import file \&quot;&quot;</span>) 
       + fileName + <span class="string">&quot;\&quot;&quot;</span>, *<span class="keyword">this</span>, m_parsedFileName);

      <span class="code_comment">//
</span>      <span class="code_comment">// inicializa o tokenizer com os ponteiros do FileMapping
</span>      <span class="code_comment">//
</span>      m_Tokenizer.assign(fileMapping.GetStart&lt;<span class="keyword">char</span>*&gt;(),
                         fileMapping.GetEnd&lt;<span class="keyword">char</span>*&gt;(),
                         char_separator&lt;<span class="keyword">char</span>&gt;(<span class="string">&quot;\t\r &quot;</span> , <span class="string">&quot;\n\&quot;*,;:{}/\[]()&quot;</span>));


      m_ParsedIncludeFiles.push_back(fileName);

   }
   <span class="keyword">else</span>
   {
      fileMapping.MapFile(fileName);
      
      <span class="keyword">if</span>(!fileMapping.IsValid())
         <span class="keyword">throw</span> ParseException(string(<span class="string">&quot;error opening file \&quot;&quot;</span>) 
       + fileName + <span class="string">&quot;\&quot;&quot;</span>, *<span class="keyword">this</span>, m_parsedFileName);

      <span class="code_comment">//
</span>      <span class="code_comment">// inicializa o tokenizer com os ponteiros do FileMapping
</span>      <span class="code_comment">//
</span>      m_Tokenizer.assign(fileMapping.GetStart&lt;<span class="keyword">char</span>*&gt;(),
         fileMapping.GetEnd&lt;<span class="keyword">char</span>*&gt;(),
         char_separator&lt;<span class="keyword">char</span>&gt;(<span class="string">&quot;\t\r &quot;</span> , <span class="string">&quot;\n\&quot;*,;:{}/\[]()&quot;</span>));

      m_parsedFileName = fileName;

      ...
   }
}
</pre>
</div>

<p>Como visto, nosso código não ficou mais complicado por causa do File Mapping. Nossa classe facilitou muito e deixou o código claro, além da inteligente decisão de fazer uma classe simples que resolvesse nosso problema pontual ao invés de tentar fazer um framework genérico para uso avançado de File Mapping. Um péssimo costume de "programadores orientados à objetos" é fazer classes super genéricas que resolvam todas as situações possíveis e imagináveis naquela área (eu sei bem porque eu era assim...).</p>

<p>Chega de yada-yada, vamos aos números:</p>

<div class="code">
<p><b>Média de tempo (50 chamadas):</b></p>
<p>
<b>228,01 ms</b> - versão usando a runtime do C++
<br>
<b>214,68 ms</b> - versão usando CreateFile
<br>
<b>204,17 ms</b> - versão usando CreateFile com FILE_FLAG_SEQUENTIAL_SCAN
<br>
<b>186,55 ms</b> - versão usando File Mapping
</p>

<p>
<b>Comparação entre a implementação com File Mapping e as anteriores</b>
<br>
<b>22,22%</b> - Melhoria em relação versão que usa a runtime do C++ (versão inicial)
<br>
<b>15,08%</b> - Melhoria em relação versão que usa CreateFile
<br>
<b>09,44%</b> - Melhoria em relação versão que usa CreateFile com FILE_FLAG_SEQUENTIAL_SCAN
</p>
</div>

<p>Nossa melhoria em relação à versão inicial foi de 22%, e as mudanças foram pequenas e pontuais. Nessa última tentativa, fizemos a classe de File Mapping (menos de 90 linhas de código e anos de estudo de C++ e Win32) e modificamos o código que carrega o arquivo (menos de 10 linhas de código e mais de 10 livros de programação depois). O nosso programa de exemplo não é tão <i>I/O intensive</i>, mas nossa otimização melhorou bastante o desempenho em termos pencentuais. </p>

<p>Mesmo assim, há algo para se pensar: será que valeu a pena? Essa série foi interessante para ilustrar conceitos de otimização de performance e Win32, mas agora chega a hora de explicar mais um conceito: comparação percentual não é suficiente para fazer um estudo sobre uma determinada otimização. 22% é uma otimização considerável, mas e em termos absolutos? Será que 41,46 milisegundos é algo que faça diferença no tempo de compilação? Nosso caso o esforço de programação foi pequeno (o de escrever os posts foi imensamente maior), mas mesmo assim deve ser levado em consideração.<p>

<p>Quando for mensurar alguma otimização, considere TODOS os parâmetros, inclusive os intangíveis, como o impacto que essa otimização causará no usuário. No caso do nosso interpretador, talvez ~40ms não faça tanta diferença. Mas em uma chamada de componente que roda no backend de uma bolsa de valores e que é chamado milhões de vezes em um único dia, 5ms faz uma diferença MUITO grande. </p>

<p>Lembre-se: programação é uma arte.</p><br><p class="datetime">Em 27/09/2005 15:44, por  Rodrigo Strauss </p>
</div>
          </td>
        </tr>



<tr>
<td class="topmenu"></td>
<td>
<br>
<center>

<script type="text/javascript"><!--
google_ad_client = "pub-2589539519655496";
google_ad_width = 728;
google_ad_height = 90;
google_ad_format = "728x90_as";
google_ad_type = "text";
google_ad_channel = "";
google_color_border = "FFFFFF";
google_color_bg = "FFFFFF";
google_color_link = "FF5000";
google_color_text = "000000";
google_color_url = "FF5000";
google_ui_features = "rc:6";
//-->
</script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>

</center>
</td>
</tr>

<tr>
 <td class="topmenu"></td>
 <td>
  <table style="margin: 0px" cellspacing="0" cellpadding="0" width="100%" border="0">
   <tr>
    <td><img src="../../../images/rebarba3.png"></td>
    <td align="right"><img src="../../../images/rebarba4.png"></td>
   </tr>
  </table>
 </td>
</tr>

<tr><td class="topmenu">&nbsp;</td><td class="topmenu">&nbsp;</td></tr>
<tr><td class="topmenu">&nbsp;</td><td>
<table style="MARGIN: 0px" cellspacing="0" cellpadding="0" width="100%" border="0">
            <tr>
              <td><img src="../../../images/rebarba1.png"></td>
              <td align="right"><img src="../../../images/rebarba2.png"></td>
              </tr>
            </table>
</td>
</tr>
 <tr><td class="topmenu">&nbsp;</td>
<td>

<div class="content">
<a name="comments"></a><h5>Comentários</h5><div class="post_comment">
<a name="2018"></a><B>Alexsabdro</B>  | <a rel="nofollow" href="../../../content.1bit/weblog/otimizacao_io_6">website</a> | em 04/09/2007 | <a rel="nofollow" href="content.1bit/weblog/otimizacao_io_6#2018">#</a><br>
Olá, é a primeira vez que vejo seus artigos e gostaria de saber se você pode postar todos esles, desde o primeiro até o ultimo. Este é a parte 6 se poder postar para o e-mail sistemaufpa@yahoo.com.br eu agradeço.<br>Desde já obrigado!
</div>
<div class="post_comment_strauss">
<a name="2021"></a><B>Rodrigo Strauss</B>  | <a rel="nofollow" href="http://www.1bit.com.br">website</a> | em 04/09/2007 | <a rel="nofollow" href="content.1bit/weblog/otimizacao_io_6#2021">#</a><br>
Na parte de cima do post, bem embaixo do título estão os links para todos os posts da série.
</div>



</div>

</td></tr>



















<tr>
          <td class="topmenu"></td>
          <td>
          <table style="margin: 0px" cellspacing="0" cellpadding="0" width="100%" border="0">
            <tr>
              <td><img src="../../../images/rebarba3.png" alt="rebarba"></td>
              <td align="right"><img src="../../../images/rebarba4.png" alt="rebarba"></td>
            </tr>
          </table>
          </td>
        </tr>

        <tr>
          <td class="topmenu">&nbsp;</td>
          <td class="topmenu" height="25" align="right" style="color:#999999;">
::::
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          </td>
        </tr>
    </table>
  </body>
</html>
