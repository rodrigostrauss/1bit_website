

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
<meta charset="utf-8">

<META NAME="author" CONTENT="Rodrigo Strauss">
<META NAME="ROBOTS" CONTENT="ALL">
    <title>Resolvendo o bug usando CComPtr  ::::  Rodrigo Strauss :: www.1bit.com.br</title>
    <link href="../../../1bit.css" type="text/css" rel="stylesheet">
    <link rel="alternate" type="text/xml" title="RSS" href="../../../weblog_rss.1bit">
</head>
  <body style="margin:0px 0px 0px 0px" bgcolor="#FFFFFF">
    <table cellspacing="0" cellpadding="0" width="100%" border="0">
        <tr>
          <td class="header" valign="middle" bgcolor="#ffffff" height="77" colspan="2">&nbsp;
<a href="../../../"><img src="../../../images/logo_novo_2.png" border="0" alt="logo" /></a>

          </td>
        </tr>
        <tr>
          <td class="topmenu"></td>
          <td class="topmenu" align="right" height="30">
		    <a class="top_menu_link" href="../../../content.1bit/contact">Contato</a> 
			<span class="menusep">|</span>
            
            <a class="top_menu_link" href="../../../content.1bit/about">Sobre...</a>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          </td>
        </tr>
        <tr>
          <td class="topmenu"></td>
          <td>
          <table style="MARGIN: 0px" cellspacing="0" cellpadding="0" width="100%" border="0">
            <tr>
              <td><img src="../../../images/rebarba1.png" alt="rebarba"></td>
              <td align="right"><img src="../../../images/rebarba2.png" alt="rebarba"></td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td class="menu" valign="top" width="175">

<div class="left_menu_section">
 <h2><a href="../../../#artigos" style="text-decoration:none;">Artigos</a></h2>
</div>

<div class="left_menu_section">
 <h2><a href="../../../content.1bit/weblog_archive" style="text-decoration:none;">Blog</a></h2>
</div>

<div class="left_menu_section">
 <h2><a href="../../../content.1bit/opensource" style="text-decoration:none;">Open Source</a></h2>
</div>

<!-- 
<div class="left_menu_section">
 <h2><a href="content.1bit/aulas" style="text-decoration:none;">Aulas online (ou não) </a></h2>
</div>
-->


<br>
<br>
<br>
<center>

<!--
<a href="http://whos.amung.us/show/xopqoakh"><img src="http://whos.amung.us/cwidget/xopqoakh/fffffff6915a.png" alt="page counter" width="81" height="29" border="0" /></a>
-->

</center>



<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
          </td>
          <td valign="top">
<div class="content">
<h4><a href="../../../content.1bit/weblog_archive" style="text-decoration:none;">Rodrigo Strauss :: Blog</a></h4>
<table border="0">
<tr>
<!-- 
<td width="60">

<a style="text-decoration:none;" href="../../weblog_rss.1bit"><img src="../../../images/xml.gif" border="0"/></a>
</td>
-->

<td>



</td>

<td>




</td>

<td align="right">




<!--

<script type="text/javascript">
google_ad_client = "pub-2589539519655496";
google_ad_width = 468;
google_ad_height = 15;
google_ad_format = "468x15_0ads_al";
google_ad_channel = "";
google_color_border = "FFFFFF";
google_color_bg = "FFFFFF";
google_color_link = "FF5000";
google_color_text = "000000";
google_color_url = "FF5000";
</script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
-->






</td>
</tr>
</table>
<br>
<h5>Resolvendo o bug usando CComPtr</h5><p>Eu resolvi <a href="../../../content.1bit/weblog/smart_ptr_1_bug">o bug</a> de diversas maneiras até agora. Eu <a href="../../../content.1bit/weblog/smart_ptr_2_bug_expl">mudei o código para contorná-lo</a>, <a href="../../../content.1bit/weblog/smart_ptr_home_made">criei um smart pointer feito em casa</a> e <a href="../../../content.1bit/weblog/cpp_sanidade_shared_ptr">usei o boost::shared_ptr</a> (melhor solução até agora). Agora eu proponho mais do que uma solução, proponho um re-arquitetura: transformar todos os objetos em objetos COM. Isso resolve nosso problema, porque em COM todos os objetos são acessados através de ponteiros para interfaces, e as regras para gerenciamento de tempo de vida desses ponteiros são bem claras. Esses objetos, apesar de serem "objetos COM", não estão disponíveis para a runtime do COM como de costume, são todos objetos privados. Futuramente, poderemos facilmente exportar esses componentes em uma DLL, para que eles sejam acessíveis através de outras ferramentas que suportam COM, como VB, Delphi ou mesmo .NET.</p>

<p>Nesse exemplo, eu segui as regras básicas do COM: todas as funcionalidades são acessíveis através de interfaces, todos os objetos herdam e implementam IUnknown e o tempo de vida de um objeto é gerenciado por chamadas a IUnknown-&gt;AddRef() e IUnknown-&gt;Release(). Para implementar IUnknown e gerenciar o tempo de vida dos objetos eu optei por usar ATL, por tornar a implementação bem mais simples.</p>

<p>Vamos ao código, ele vale muito:</p> 

<div class="code">
<pre>
#define UNICODE
#define _UNICODE

// "descomente" isso se usar um projeto do VC com "precompiled header"
// #include "stdafx.h"


//
// só precisamos disso para usar ATL
//
#include &lt;atlbase.h&gt;

ATL::CComModule _Module;

#include &lt;atlcom.h&gt;


//
// isso evita erros na conversão de ponteiros COM
// eu expliquei isso em <a href="../../../content.1bit/weblog/cpp_comma_op">../../../content.1bit/weblog/cpp_comma_op</a>
//
#define IC(pp) (static_cast&lt;IUnknown*&gt;(*pp),(void**)pp)

//
// Essa será nossa interface. Antes que você pergunte,
// SIM, C++ TEM SUPORTE A INTERFACES
// é só definir todos os métodos como virtual e colocar um "=0"
// no final para dizer que não é implementado
//
struct __declspec(uuid("D0C2F56E-704E-45ce-B6F8-7E9D0F7F8723"))
ITest1 : public IUnknown  // toda interface COM herda de IUnknown
{
	virtual HRESULT get_dw(DWORD* pdw) =0;
	virtual HRESULT set_dw(DWORD dw) =0;
	virtual HRESULT set_bstrValue(BSTR str) =0;
	virtual HRESULT get_bstrValue(BSTR* pbstr) =0;
};


class CTest1 : 
	public CComObjectRootEx&lt;CComSingleThreadModel&gt;, // implementação ATL de IUnknown
	public ITest1
{
private:
	DWORD m_dwValue;
	//
	// nossa string agora será um BSTR. Vamos usar CComBSTR para não
	// nos preocuparmos com gerenciamento de memória
	//
    CComBSTR m_bstrValue;
	
public:
	
	CTest1() : m_dwValue(0)
	{}
	
	//
	// Para fazer um objeto COM o ATL só precisa que você herde de
	// CComObjectRootEx (ou similares) e coloque um mapa de interfaces
	//
	BEGIN_COM_MAP(CTest1)
		COM_INTERFACE_ENTRY(ITest1)
	END_COM_MAP()
	
	
	//
	//  implementação de ITest1
	//
	HRESULT get_dw(DWORD* pdw)
	{
		if(!pdw)
			return E_POINTER;
		
		*pdw = m_dwValue;
		
		return S_OK;
	}
	
	HRESULT set_dw(DWORD dw)
	{
		m_dwValue = dw;
		return S_OK;
	}
	
	HRESULT set_bstrValue(BSTR str)
	{
		m_bstrValue = str;
		
		return S_OK;
	}
	
	HRESULT get_bstrValue(BSTR* pbstr)
	{
		if(!pbstr)
			return E_POINTER;
		
		*pbstr = m_bstrValue.Copy();
		
		return S_OK;
	}

	//
	// vamos facilitar nossa vida
	//
	typedef ATL::CComCreator&lt;CComObject&lt;CTest1&gt; &gt; Creator;
};


//
// Interface ITest2
//
struct __declspec(uuid("7BA53C86-5B50-4b69-ACC4-652E60FE2FC9"))
ITest2 : public IUnknown  
{
	virtual HRESULT Init(DWORD dw, BSTR str) =0;
	virtual HRESULT GetTest1(ITest1** ppTest1) =0;
};


class CTest2 : 	
	public CComObjectRootEx&lt;CComSingleThreadModel&gt;, // implementação ATL de IUnknown
	public ITest2
{
private:
	//
	// vamos usar o CComPtr para não nos preocuparmos com
	// gerenciamento de tempo de vida do objeto COM
	//
	CComPtr&lt;ITest1&gt; m_pTest1;
public:

	BEGIN_COM_MAP(CTest2)
		COM_INTERFACE_ENTRY(ITest2)
	END_COM_MAP()

   //
   // Não preciso um destrutor para desalocar o ponteiro.
   // E nem precisei usar um linguagem mais limitada ou uma runtime lenta
   //
   
   //
   // implementação de ITest2
   //
   
   HRESULT Init(DWORD dw, BSTR str)
   {
	   HRESULT hr;

	   hr = CTest1::Creator::CreateInstance(NULL, __uuidof(ITest1), IC(&m_pTest1));
	   
	   if(FAILED(hr))
		   return hr;

	   m_pTest1-&gt;set_dw(dw);
	   m_pTest1-&gt;set_bstrValue(str);

	   return S_OK;
   }

   HRESULT GetTest1(ITest1** ppTest1)
   {
	   *ppTest1 = NULL;

	   if(m_pTest1.p == NULL)
		   return E_UNEXPECTED;

	   return m_pTest1.CopyTo(ppTest1);
   }

   typedef ATL::CComCreator&lt;CComObject&lt;CTest2&gt; &gt; Creator;
};

int main(int argc, char* argv[])
{
	CComPtr&lt;ITest1&gt; pTest1;
	CComPtr&lt;ITest2&gt; pTest2;
	CComBSTR bstr;
	DWORD dw;

	CTest1::Creator::CreateInstance(NULL, __uuidof(ITest1), IC(&pTest1));
	CTest2::Creator::CreateInstance(NULL, __uuidof(ITest2), IC(&pTest2));

	bstr = L"Oi mamãe, eu sou uma string";
	dw = 10;

	pTest1-&gt;set_bstrValue(bstr);
	pTest1-&gt;set_dw(dw);

	pTest2-&gt;Init(dw, bstr);

	//
	// se você não fizer isso antes de reusar a variável para um parâmetro
	// OUT, o CComPtr vai disparar um ASSERT, pq isso criaria um leak.
	// Quando você atribui NULL à um CComPtr é o equivalente do VB 
	// a "Set p = Nothing" (libera o objeto)
	//
	pTest1 = NULL;

	pTest2-&gt;GetTest1(&pTest1);

	//
	// o mesmo problema com o CComBSTR. Precisamos liberá-lo antes de reusar
	// para um parâmetro OUT. Ok, ainda tem que fazer algum gerenciamento de 
	// memória manualmente.
	//
	bstr.Empty();

	pTest1-&gt;get_bstrValue(&bstr);
	pTest1-&gt;get_dw(&dw);
	
	return 0;
}</pre></div>

<p>Para compilar esse projeto, <b>não</b> crie um projeto ATL no Visual C++, senão você terá uma DLL. Crie um projeto "Win32 Console Application", ou compile isso em linha de comando com o <a href="http://msdn.microsoft.com/visualc/vctoolkit2003/">Visual C++ Toolkit</a>.</p><br><p class="datetime">Em 27/06/2005 15:00, por  Rodrigo Strauss </p>
</div>
          </td>
        </tr>



<tr>
<td class="topmenu"></td>
<td>
<br>
<center>

<script type="text/javascript"><!--
google_ad_client = "pub-2589539519655496";
google_ad_width = 728;
google_ad_height = 90;
google_ad_format = "728x90_as";
google_ad_type = "text";
google_ad_channel = "";
google_color_border = "FFFFFF";
google_color_bg = "FFFFFF";
google_color_link = "FF5000";
google_color_text = "000000";
google_color_url = "FF5000";
google_ui_features = "rc:6";
//-->
</script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>

</center>
</td>
</tr>

<tr>
 <td class="topmenu"></td>
 <td>
  <table style="margin: 0px" cellspacing="0" cellpadding="0" width="100%" border="0">
   <tr>
    <td><img src="../../../images/rebarba3.png"></td>
    <td align="right"><img src="../../../images/rebarba4.png"></td>
   </tr>
  </table>
 </td>
</tr>

<tr><td class="topmenu">&nbsp;</td><td class="topmenu">&nbsp;</td></tr>
<tr><td class="topmenu">&nbsp;</td><td>
<table style="MARGIN: 0px" cellspacing="0" cellpadding="0" width="100%" border="0">
            <tr>
              <td><img src="../../../images/rebarba1.png"></td>
              <td align="right"><img src="../../../images/rebarba2.png"></td>
              </tr>
            </table>
</td>
</tr>
 <tr><td class="topmenu">&nbsp;</td>
<td>

<div class="content">
<a name="comments"></a><h5>Comentários</h5><div class="post_comment">
<a name="407"></a><B>Wanderley Caloni Jr</B>  | <a rel="nofollow" href="http://www.caloni.com.br">website</a> | em 27/06/2005 | <a rel="nofollow" href="../#407">#</a><br>
Moral da história: ATL facilita e é enxuto. Torna uma tarefa aparentemente complexa em C++ (como implementar IUnknown e Agregation em MTA e STA) em algo quase tão simples quanto .NET.<br><br>Sem contar que pro usuário dessas classes a preocupação com o como foi implementado é nula. Prova disso é que ao ser exportado para linguagens de mais alto nível só existirão os métodos a serem chamados.
</div>
<div class="post_comment">
<a name="430"></a><B>Fabio Galuppo</B>  | em 13/07/2005 | <a rel="nofollow" href="../#430">#</a><br>
Ok, se a idéia é futuramente exportar como componente COM. Se quiser apenas compartilhar as interfaces, acredito que a mesma solução pode ser feita puramente em C++. :) Os próprios "smart pointers" ( auto_ptr e o futuro C++0x shared_ptr ) do C++ poderiam ser aplicados. A propósito vc "postou" a solução boost::shared_ptr, por aqui?<br><br>Grande abraço
</div>
<div class="post_comment">
<a name="431"></a><B>Fabio Galuppo</B>  | em 13/07/2005 | <a rel="nofollow" href="../#431">#</a><br>
Ok vi o link agora :(
</div>



</div>

</td></tr>



















<tr>
          <td class="topmenu"></td>
          <td>
          <table style="margin: 0px" cellspacing="0" cellpadding="0" width="100%" border="0">
            <tr>
              <td><img src="../../../images/rebarba3.png" alt="rebarba"></td>
              <td align="right"><img src="../../../images/rebarba4.png" alt="rebarba"></td>
            </tr>
          </table>
          </td>
        </tr>

        <tr>
          <td class="topmenu">&nbsp;</td>
          <td class="topmenu" height="25" align="right" style="color:#999999;">
::::
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          </td>
        </tr>
    </table>
  </body>
</html>
