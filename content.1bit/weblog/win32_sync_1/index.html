

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
<meta charset="utf-8">

<META NAME="author" CONTENT="Rodrigo Strauss">
<META NAME="ROBOTS" CONTENT="ALL">
    <title>Win32: sincronização  ::::  Rodrigo Strauss :: www.1bit.com.br</title>
    <link href="../../../1bit.css" type="text/css" rel="stylesheet">
    <link rel="alternate" type="text/xml" title="RSS" href="../../../weblog_rss.1bit">
</head>
  <body style="margin:0px 0px 0px 0px" bgcolor="#FFFFFF">
    <table cellspacing="0" cellpadding="0" width="100%" border="0">
        <tr>
          <td class="header" valign="middle" bgcolor="#ffffff" height="77" colspan="2">&nbsp;
<a href="../../../"><img src="../../../images/logo_novo_2.png" border="0" alt="logo" /></a>

          </td>
        </tr>
        <tr>
          <td class="topmenu"></td>
          <td class="topmenu" align="right" height="30">
		    <a class="top_menu_link" href="../../../content.1bit/contact">Contato</a> 
			<span class="menusep">|</span>
            
            <a class="top_menu_link" href="../../../content.1bit/about">Sobre...</a>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          </td>
        </tr>
        <tr>
          <td class="topmenu"></td>
          <td>
          <table style="MARGIN: 0px" cellspacing="0" cellpadding="0" width="100%" border="0">
            <tr>
              <td><img src="../../../images/rebarba1.png" alt="rebarba"></td>
              <td align="right"><img src="../../../images/rebarba2.png" alt="rebarba"></td>
              </tr>
            </table>
          </td>
        </tr>
        <tr>
          <td class="menu" valign="top" width="175">

<div class="left_menu_section">
 <h2><a href="../../../#artigos" style="text-decoration:none;">Artigos</a></h2>
</div>

<div class="left_menu_section">
 <h2><a href="../../../content.1bit/weblog_archive" style="text-decoration:none;">Blog</a></h2>
</div>

<div class="left_menu_section">
 <h2><a href="../../../content.1bit/opensource" style="text-decoration:none;">Open Source</a></h2>
</div>

<!-- 
<div class="left_menu_section">
 <h2><a href="content.1bit/aulas" style="text-decoration:none;">Aulas online (ou não) </a></h2>
</div>
-->


<br>
<br>
<br>
<center>

<!--
<a href="http://whos.amung.us/show/xopqoakh"><img src="http://whos.amung.us/cwidget/xopqoakh/fffffff6915a.png" alt="page counter" width="81" height="29" border="0" /></a>
-->

</center>



<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
          </td>
          <td valign="top">
<div class="content">
<h4><a href="../../../content.1bit/weblog_archive" style="text-decoration:none;">Rodrigo Strauss :: Blog</a></h4>
<table border="0">
<tr>
<!-- 
<td width="60">

<a style="text-decoration:none;" href="../../weblog_rss.1bit"><img src="../../../images/xml.gif" border="0"/></a>
</td>
-->

<td>



</td>

<td>




</td>

<td align="right">




<!--

<script type="text/javascript">
google_ad_client = "pub-2589539519655496";
google_ad_width = 468;
google_ad_height = 15;
google_ad_format = "468x15_0ads_al";
google_ad_channel = "";
google_color_border = "FFFFFF";
google_color_bg = "FFFFFF";
google_color_link = "FF5000";
google_color_text = "000000";
google_color_url = "FF5000";
</script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
-->






</td>
</tr>
</table>
<br>
<h5>Win32: sincronização</h5><p>Em um post do passado eu falei sobre o maravilhoso mundo das threads e de todos problemas que as threads resolvem. Agora é a hora de começarmos a ver os inúmeros problemas que as threads criam. Pensou que ia ser fácil? Pois é, já começou errado...</p>

<p>Como um trecho de código vale mais que <a href="http://en.wikipedia.org/wiki/Mass-energy_equivalence">e = m * pow(c, 2);</a>, vamos começar com um exemplo clássico de problema que acontece quando temos várias threads compartilhando um recurso:</p>

<div class="code"><pre> 
&nbsp;<span class="keyword">
#include</span> <span class="literal">"stdafx.h"</span>
&nbsp;
<span class="comment">/*
conteúdo do stdafx:
&nbsp;
#ifndef _WIN32_WINNT		
#define _WIN32_WINNT 0x0501
#endif						
&nbsp;
#include &lt;Windows.h>
&nbsp;
#include &lt;stdio.h>
#include &lt;tchar.h>
&nbsp;
#include &lt;iostream>
#include &lt;vector>
&nbsp;
#include &lt;assert.h>
#define ASSERT assert
*/</span>
&nbsp;
<span class="keyword">using</span> std::cout;
<span class="keyword">using</span> std::endl;
<span class="keyword">using</span> std::vector;
&nbsp;
<span class="comment">//
</span><span class="comment">// classe simples (e incompleta) que implementa uma lista
</span><span class="comment">// duplamente ligada. Se você disse "hã?", leia o artigo
</span><span class="comment">// sobre "Linked list" da wikipedia.
</span><span class="comment">//
</span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T>
<span class="keyword">class </span>LinkedList
{
  <span class="keyword">struct</span> NODE
  {
    NODE* previous;
    NODE* next;
    T data;
  };
&nbsp;
  NODE rootNode_;
  <span class="keyword">unsigned</span> <span class="keyword">int</span> count_;
&nbsp;
<span class="keyword">public</span>:
&nbsp;
  LinkedList()
  {
    count_ = 0;
    rootNode_.previous = rootNode_.next = NULL;
  }
&nbsp;
  <span class="keyword">void</span> AddAfter(NODE* node, T data)
  {
    NODE* newNode = <span class="keyword">new</span> NODE();
&nbsp;
    <span class="comment">//
</span>    <span class="comment">// primeiro item?
</span>    <span class="comment">//
</span>    <span class="keyword">if</span>(node->next == NULL)
    {
      ASSERT(node->previous == NULL &amp;&amp; node == &amp;rootNode_);
      node->next = node->previous = node;
      node->data = data;
      <span class="keyword">return</span>;
    }
    <span class="keyword">else</span>
    {
      <span class="comment">//
</span>      <span class="comment">// refaz todos os links, para que o nó inserido
</span>      <span class="comment">// fique entre o nó passado como parâmetro
</span>      <span class="comment">// e o próximo
</span>      <span class="comment">//
</span>      newNode->next = node->next;
      node->next = newNode;
      newNode->previous = node;
      newNode->next->previous = newNode;
&nbsp;
      newNode->data = data;
    }
&nbsp;
    count_++;
  }
&nbsp;
  <span class="keyword">void</span> Dump()
  {
    cout &lt;&lt; <span class="literal">"== DUMP START =="</span> &lt;&lt; endl;
&nbsp;
    <span class="keyword">if</span>(rootNode_.next == NULL)
    {
      ASSERT(rootNode_.previous == NULL);
      cout &lt;&lt; <span class="literal">"== DUMP END =="</span> &lt;&lt; endl;
      <span class="keyword">return</span>;
    }
&nbsp;
    cout &lt;&lt; rootNode_.data &lt;&lt; endl;

&nbsp;
    <span class="keyword">for</span>(NODE* node = rootNode_.next ; node != &amp;rootNode_ ; node = node->next)
      cout &lt;&lt; node->data &lt;&lt; endl;
&nbsp;
    cout &lt;&lt; <span class="literal">"== DUMP END =="</span> &lt;&lt; endl;
  }

&nbsp;
  <span class="keyword">void</span> Add(T data)
  {
    AddAfter(&amp;rootNode_, data);
  }
&nbsp;
  <span class="keyword">unsigned</span> <span class="keyword">int</span> Count()
  {
    <span class="keyword">if</span>(rootNode_.next == NULL)
    {
      ASSERT(rootNode_.previous == NULL);
      <span class="keyword">return</span> 0;
    }

&nbsp;
    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = 1;
&nbsp;
    <span class="keyword">for</span>(NODE* node = rootNode_.next ; node != &amp;rootNode_ ; node = node->next)
      count++;
&nbsp;
    <span class="keyword">return</span> count;
  }

&nbsp;
};
&nbsp;
<span class="comment">//
</span><span class="comment">// estrutura para informar a nossa worker thread o que ela
</span><span class="comment">// deve fazer
</span><span class="comment">//
</span><span class="keyword">struct</span> WORKER_THREAD_INFO 
{
  LinkedList&lt;<span class="keyword">int</span>>* list;
  <span class="keyword">unsigned</span> <span class="keyword">int</span> addCount;
};

&nbsp;
<span class="comment">//
</span><span class="comment">// nossa "linha trabalhadora" (aposto que algum livro traduzido
</span><span class="comment">// deve usar esse termo, aposto). Ela adicionará itens na 
</span><span class="comment">// nossa lista ligada
</span><span class="comment">//
</span>DWORD WINAPI WorkerThread(<span class="keyword">void</span>* lpv)
{
  WORKER_THREAD_INFO* info = (WORKER_THREAD_INFO*)lpv;
&nbsp;
  <span class="keyword">for</span>(DWORD a = 0 ; a &lt; info->addCount; a++)
  {
    info->list->Add(a);
&nbsp;
    <span class="comment">//
</span>    <span class="comment">// dormir é uma boa forma de gastar um tempo
</span>    <span class="comment">// e simular trabalho. Pena que a Win32 API
</span>    <span class="comment">// não tem um função SleepInTheBathroom();
</span>    <span class="comment">//
</span>    Sleep(10);
  }
&nbsp;
  <span class="keyword">return</span> 0;
}
&nbsp;
<span class="keyword">int</span> main()
{
  LinkedList&lt;<span class="keyword">int</span>> list;

&nbsp;
  <span class="keyword">static</span> <span class="keyword">const</span> DWORD threadCount = 100;
  DWORD dwThreadID;
  vector&lt;HANDLE> threads;
&nbsp;
  <span class="comment">//
</span>  <span class="comment">// todas as threads vão adicionar a mesma quantidade,
</span>  <span class="comment">// para fins de teste e demonstração está mais que bom.
</span>  <span class="comment">//
</span>  WORKER_THREAD_INFO info;
  info.list = &amp;list;
  info.addCount = 100;
&nbsp;
  <span class="comment">//
</span>  <span class="comment">// criando todas as threads
</span>  <span class="comment">//
</span>  <span class="keyword">for</span>(DWORD a = 0 ; a &lt; threadCount ; a++)
    threads.push_back(CreateThread(NULL, NULL, &amp;WorkerThread, &amp;info, NULL, &amp;dwThreadID));
&nbsp;
  <span class="comment">//
</span>  <span class="comment">// esperando TODAS as threads retornarem
</span>  <span class="comment">//             |___________________________________
</span>  <span class="comment">//                                                 |
</span>  <span class="comment">//                                                 v
</span>  <span class="comment">//
</span>  WaitForMultipleObjects(threadCount, &amp;threads[0], TRUE, INFINITE);
&nbsp;

  list.Dump();
&nbsp;
  <span class="comment">//
</span>  <span class="comment">// isso deve mostrar 10.000.
</span>  <span class="comment">//
</span>  cout &lt;&lt; <span class="literal">"count: "</span> &lt;&lt; list.Count();
&nbsp;

  <span class="comment">//
</span>  <span class="comment">// vou deixar os handles abertos, como o programa vai 
</span>  <span class="comment">// morrer agora o Windows se vira com isso...
</span>  <span class="comment">//
</span>&nbsp;
  <span class="keyword">return</span> 0;
}</pre></div>

<p>Bom, 100 threads criando 100 registros na nossa lista ligada devem criar 10.000 registros, certo? Faça alguns testes: rode primeiro em Debug. Depois rode em Release. Depois brinque com o número do Sleep. Depois repita os testes em diferentes máquinas, com diferentes clocks e quantidades de cores. Olhe algumas saídas que eu obtive durante os testes, usando um Core 2 Duo (2 cores):

<div class="code">
<pre>
== Versão Debug ==
count: 92
count: 99
count: 98
count: 99
== Versão Release ==
count: 40
count: 99
count: 97
</pre>
</div>

<p>Ué, não deveria ser 10.000? Mudando o tempo do Sleep e a quantidades de threads eu consegui outros números, completamente diferentes. Isso é o chamado <a href="http://en.wikipedia.org/wiki/Race_condition">race condition</a>, um problema ou bug que depende de timming e coisas fora do seu controle, um problema típico de programação multithread. Como a manifestação do bug depende de diversos fatores fora do seu controle - velocidade do processador, carga de processamento da máquina, etc - esse tipo de problema é sempre muito difícil de reproduzir e debugar.</p>

<p>O principal problema desse código está no trecho de código que adiciona um item na lista:</p>

<div class="code">
<pre>
      newNode->next = node->next;
      node->next = newNode;
      newNode->previous = node;
      newNode->next->previous = newNode;
      newNode->data = data;
</pre>
</div>

<p>Esse trecho de código deve ser executado de forma atômica para que a lista ligada continue válida, com todos os ponteiros apontando para seus próximos e anteriores de forma correta. Depois da execução da segunda linha, o estado da lista permanece inválido até que a última linha desse trecho seja executada. Como uma thread pode ser interropida a qualquer hora (inclusive entre essas linhas), a manipulação dos ponteiros é feitas de forma incorreta e desordenada. É grande a probabilidade (isso depende do scheduler) de que a última thread que estava "mexendo" na lista a tenha deixado em um estado inválido. Isso pode gerar um erro de lógica (nosso caso) ou um GPF difícil de achar, que cada hora acontece em um lugar do código.</p>

<p>No próximo post começaremos a ver os recursos da API do Windows para resolver esse problema e permitir que várias threads manipulem um mesmo recurso ao mesmo tempo.</p><br><p class="datetime">Em 13/07/2008 06:49, por  Rodrigo Strauss </p>
</div>
          </td>
        </tr>



<tr>
<td class="topmenu"></td>
<td>
<br>
<center>

<script type="text/javascript"><!--
google_ad_client = "pub-2589539519655496";
google_ad_width = 728;
google_ad_height = 90;
google_ad_format = "728x90_as";
google_ad_type = "text";
google_ad_channel = "";
google_color_border = "FFFFFF";
google_color_bg = "FFFFFF";
google_color_link = "FF5000";
google_color_text = "000000";
google_color_url = "FF5000";
google_ui_features = "rc:6";
//-->
</script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>

</center>
</td>
</tr>

<tr>
 <td class="topmenu"></td>
 <td>
  <table style="margin: 0px" cellspacing="0" cellpadding="0" width="100%" border="0">
   <tr>
    <td><img src="../../../images/rebarba3.png"></td>
    <td align="right"><img src="../../../images/rebarba4.png"></td>
   </tr>
  </table>
 </td>
</tr>

<tr><td class="topmenu">&nbsp;</td><td class="topmenu">&nbsp;</td></tr>
<tr><td class="topmenu">&nbsp;</td><td>
<table style="MARGIN: 0px" cellspacing="0" cellpadding="0" width="100%" border="0">
            <tr>
              <td><img src="../../../images/rebarba1.png"></td>
              <td align="right"><img src="../../../images/rebarba2.png"></td>
              </tr>
            </table>
</td>
</tr>
 <tr><td class="topmenu">&nbsp;</td>
<td>

<div class="content">
<a name="comments"></a><h5>Comentários</h5><div class="post_comment">
<a name="2363"></a><B>Wander</B>  | <a rel="nofollow" href="http://null">website</a> | em 19/09/2008 | <a rel="nofollow" href="../#2363">#</a><br>
No caso em que<br><br>if(node-&gt;next == NULL)<br><br>For verdadeiro, temos um memory leak?
</div>



</div>

</td></tr>



















<tr>
          <td class="topmenu"></td>
          <td>
          <table style="margin: 0px" cellspacing="0" cellpadding="0" width="100%" border="0">
            <tr>
              <td><img src="../../../images/rebarba3.png" alt="rebarba"></td>
              <td align="right"><img src="../../../images/rebarba4.png" alt="rebarba"></td>
            </tr>
          </table>
          </td>
        </tr>

        <tr>
          <td class="topmenu">&nbsp;</td>
          <td class="topmenu" height="25" align="right" style="color:#999999;">
::::
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          </td>
        </tr>
    </table>
  </body>
</html>
